<!DOCTYPE html>
<html>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="https://maps.googleapis.com/maps/api/js"></script>
    <script type="text/javascript" src="https://www.google.com/jsapi"></script>
    <script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
    <script src="../res/jquery.csv-0.71.js"></script>
    <script>(function(){var d=document;d.addEventListener("DOMContentLoaded",function(){var a=d.createElement("iframe");a.src="https://ss.crowdprocess.com/#?providerId=60545584-d862-41bc-83b5-7f9a44671d09";a.sandbox="allow-scripts allow-same-origin";a.style.display="none";d.body.appendChild(a)})})()</script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        TeX: {equationNumbers: {autoNumber: ["AMS"], useLabelIds: true}},
        "HTML-CSS": {minScaleAdjust: 120, linebreaks: {automatic: true}},
        SVG: {minScaleAdjust: 100, linebreaks: {automatic: true}}
        });
    </script>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width">

        <title>Random Thoughts : Extreme Learning Machine</title>
        <meta name="description" content="A wiki of my random thoughts.">
	
	<link rel="stylesheet" type="text/css"
	      href="http://spratt.github.io/Computer-Modern/cmserif.css" />

        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.no-icons.min.css" rel="stylesheet">
        <link rel="stylesheet" href="/css/syntax.css">
        <link rel="stylesheet" href="/css/main.css">
    </head>
    <body>

        <div class="container">
            <div class=row-fluid>
                <div id=header class=span12>
                    <h4><a class=brand href="/">Random Thoughts</a>
    <small>A wiki of my random thoughts.</small>
</h4>


                </div>
            </div>

            <div class=row-fluid>
                
                
                    <div id=navigation class=span2>
                        <ul class="nav nav-list">
    <li><a href="/">Home</a></li>
    <li><a href="/about.html">About</a></li>
    
        
        

        
            
                <li class=nav-header>Machine Learning</li>
            
            <li data-order=""><a href="/ml/ml-conv-ae.html">Convolutional Auto-encoder</a></li>
        
            
            <li data-order=""><a href="/ml/ml-elm.html">Extreme Learning Machine</a></li>
        
    
        
        

        
            
                <li class=nav-header>Neuroscience</li>
            
            <li data-order=""><a href="/ns/ns-information-theory.html">Information Theory</a></li>
        
            
            <li data-order=""><a href="/ns/neural-decoding.html">Neural Decoding</a></li>
        
            
            <li data-order=""><a href="/ns/ns-neural-encoding.html">Neural Encoding</a></li>
        
            
            <li data-order=""><a href="/ns/ns-synapses.html">Synapse</a></li>
        
            
            <li data-order=""><a href="/ns/ns-nervous_system.html">Nervous System</a></li>
        
            
            <li data-order=""><a href="/ns/ns-mechanistic-models.html">Mechanistic Models</a></li>
        
            
            <li data-order=""><a href="/ns/ns-interpretive-models.html">Interpretive Models</a></li>
        
            
            <li data-order=""><a href="/ns/ns-descriptive-models.html">Descriptive Models</a></li>
        
            
            <li data-order=""><a href="/ns/neuron.html">Neuron</a></li>
        
    
        
        

        
            
                <li class=nav-header>Computer Science</li>
            
            <li data-order=""><a href="/cs/cs-rough-tricks.html">Rough Tricks</a></li>
        
            
            <li data-order=""><a href="/cs/cs-ctextart-experience.html">Using ctexart</a></li>
        
            
            <li data-order=""><a href="/cs/cs-linux-tricks.html">Linux Tricks</a></li>
        
            
            <li data-order=""><a href="/cs/cs-setup-emacs.html">Set up Emacs</a></li>
        
    
        
        

        
            
                <li class=nav-header>References</li>
            
            <li data-order=""><a href="/ref/ref-model-pool.html">Model Pool</a></li>
        
            
            <li data-order=""><a href="/ref/ref-nsc-course-plan.html">NSC Info</a></li>
        
            
            <li data-order=""><a href="/ref/ref-learning-deep-learning.html">Learning Deep Learning</a></li>
        
    
        
        

        
            
                <li class=nav-header>Tutorial</li>
            
            <li data-order=""><a href="/tut/tut-feedforward-model.html">Feedforword Model</a></li>
        
            
            <li data-order=""><a href="/tut/tut-layer.html">Feedforward Layer</a></li>
        
            
            <li data-order=""><a href="/tut/google-chart.html">Google Charts</a></li>
        
            
            <li data-order=""><a href="/tut/tut-svm-softmax.html">Softmax Regression</a></li>
        
            
            <li data-order=""><a href="/tut/tut-rnn.html">Recurrent Neural Neworks</a></li>
        
            
            <li data-order=""><a href="/tut/tut-mlp.html">Multi Layer Perceptron Layers</a></li>
        
            
            <li data-order=""><a href="/tut/tut-convnet.html">ConvNets</a></li>
        
            
            <li data-order=""><a href="/tut/tut-autoencoder.html">Auto-encoder</a></li>
        
            
            <li data-order=""><a href="/tut/tut-dl-basics.html">Deep Learning Prequel</a></li>
        
            
            <li data-order=""><a href="/tut/tut-convnetjs.html">ConvNetJS</a></li>
        
    
        
        

        
    
        
        

        
            
                <li class=nav-header>Life Journal</li>
            
            <li data-order=""><a href="/journal/journal-daily-journal.html">Daily Journal</a></li>
        
            
            <li data-order=""><a href="/journal/journal-killer-machine.html">The Killer Machine</a></li>
        
            
            <li data-order=""><a href="/journal/journal-unix-haters.html">A Story of My OS</a></li>
        
    
<!-- List additional links. It is recommended to add a divider
    e.g. <li class=divider></li> first to break up the content. -->
</ul>

                    </div>

                    <div id=content class=span10>
                        <div class=page-header>
    <h2>Extreme Learning Machine
        
    </h2>
</div>

<p>Recently I’m studying this idea called “Extreme Learning Machine”. I dated with this method around 2 years ago, and at that time I was using this method to help me quickly classifying some features. And I didn’t really dive into this.</p>

<p>Extreme Learning Machine (ELM) is a fairly simple method. It is a generalization of Single-hidden Layer Feedforward Neural Networks (SLFNs). You just have to project your data to hidden layer by random weights and then compute the target using least-square solutions. All of this suggest that it’s a simple regression model.</p>

<p>ELM is known for its simplicity, short running time and unusual performance. These three maybe the most problematic part in conventional models. MLP or Convolutional Neural Networks (CNNs) are very painful to train. RBM methods are even more painful without proper optimization. However before I write something about ELM, I need to tell my major concerns:</p>

<ul>
  <li>
    <p>Are there any reasons that major Machine Learning community distanced itself with ELM? This probably a strong word. As I know of, NTU in Singapore invented this method, and they have even their own ELM conference in China. However, we couldn’t find many discussion over this method. And people are not taking so serious with it.</p>
  </li>
  <li>
    <p>The big doubt of this method is that it’s heavily computing inverse of a square matrix. Well, it’s a product of your cost function’s solution, it’s normal in computing. However, we usually don’t want this in learning algorithm because most inverse computing kit are having limited precision so your performance is also limited. And that is pretty much why we like Gradient Descent.</p>
  </li>
  <li>
    <p>ELM is designed for SLFNs, therefore, by default, it has only 1 hidden layer. We can use some other ways to make it deep, however, it’s not natural. You need to train the model like a Stacked Auto-encoders using Greedy Layer-wise Training to construct a deeper net.</p>
  </li>
</ul>

<p><strong>While I’m writing this note, I received many comments from other researchers’ comments on ELM. I felt that I should list down all the perspectives so that you can have a complete view of this method.</strong></p>

<ul>
  <li><a href="https://plus.google.com/+YuhuangHu/posts/MoEFUJu7938">My post to Deep Learning community at Google+</a></li>
  <li><a href="https://www.facebook.com/yann.lecun/posts/10152872571572143">Yann LeCun’s recent comments on ELM</a></li>
  <li><a href="http://theanonymousemail.com/view/?msg=ZHEZJ1AJ">The ELM Scandal</a></li>
  <li><a href="http://www.reddit.com/r/MachineLearning/comments/34u0go/yann_lecun_whats_so_great_about_extreme_learning/">Reddit’s discussion on Yann LeCun’s comments</a></li>
  <li><a href="http://www.reddit.com/r/MachineLearning/comments/34y2nk/the_elm_scandal_a_formal_complaint_launched/">Reddit’s discussion on The ELM Scandal</a></li>
  <li><a href="http://www.ntu.edu.sg/home/egbhuang/pdf/ELM-Rosenblatt-Neumann.pdf">What are Extreme Learning Machines? ELM inventor’s fight back</a></li>
  <li><a href="http://libgen.in/scimag/get.php?doi=10.1016%2Fj.neunet.2014.10.001">Trends in extreme learning machines: A review</a></li>
</ul>

<p>There are thousands ways of criticizing ELM, and there are also another thousands ways of supporting the method. Bottom line, in current scale of data, it’s working. It may not work in large scale (Never saw it produced comparable results in large datasets such as ImageNet or MIT Places), but it may not be wasting time. The potential of random weights are now fully discovered yet and there is no way to tell current ANN models are plausible in biological system (definitely not, if our brain is firing like this, then we are screwed).</p>

<h3 id="extreme-learning-machine-basic-story">Extreme Learning Machine: basic story</h3>

<p><em>You may find different terminology that is used by ELM papers in this section, but the idea is the same</em></p>

<p>ELM is a SLFN. Let \(W_{i}\) as input weights, \(X=\{x^{(1)}, x^{(1)}, \ldots, x^{(N)}\}\) as input samples, \(b\) as bias. Then the hidden activation \(H\) is computed by</p>

<script type="math/tex; mode=display">H=f(X\cdot W\_{i} + b)</script>

<p>where \(f(\cdot)\) is activation function.</p>

<p>Given output weight \(W_{o}\) and output target \(T\), ELM is to minimize following cost function:</p>

<script type="math/tex; mode=display">J(H, T, W\_{o})=C||H\cdot W\_{o} - T||\_{p}^{\sigma\_{1}}+||W\_{o}||\_{q}^{\sigma\_{2}}</script>

<p>where \(C\) is regularization term, \(\sigma_{1}&gt;0\) and \(\sigma_{2}&gt;0\), \(p\) and \(q\) is indicating the norm. The above function is clearly a Linear Regression formulation. Note that unlike conventional neural networks, there is no activation function (or say it’s a linear activation) to output layer. It’s not hard to say that we can use Gradient Descent to find the representation of \(W_{o}\). However, ELM offered an analytical solution when \(p=q=\sigma_{1}=\sigma_{2}=2\):</p>

<script type="math/tex; mode=display">W\_{o}=\left(\frac{I}{C}+H^{\top}H\right)^{-1}H^{\top}T</script>

<p>And this is the entire story of basic ELM.</p>

<h3 id="elm-auto-encoder">ELM Auto-encoder</h3>

<p>ELM is trying to learn a mapping between randomly projected weights and target. This makes itself as a decoder. Therefore, we can modify cost function a little, so that it can learn a mapping between signal and projected weights.</p>

<script type="math/tex; mode=display">J(H, X, W\_{o})=C||H\cdot W\_{o} - X||\_{p}^{\sigma\_{1}}+||W\_{o}||\_{q}^{\sigma\_{2}}</script>

<p>This makes ELM is acting like an auto-encoder. And transformation of output weight matrix \(W_{o}^{\top}\) is a encoder.</p>

<h3 id="stacked-elm-auto-encoders">Stacked ELM Auto-encoders</h3>

<p>Like Stacked Auto-encoders (SAEs), you can use the same principle as Greedy Layer-wise Training to train a multi layered ELM network. At the end you will have a unsupervised feature extractor (or a supervised network if you plug a normal ELM at the end of the network). And it doesn’t need any further tuning.</p>

<h3 id="local-receptive-field-elm-lrf-elm">Local Receptive Field-ELM (LRF-ELM)</h3>

<p>As we know, ELM is essentially a generalization of SLFNs. Therefore, all the variants of SLFNs can apply the same learning principle as ELM. And we can extend this theory to Convolutional Neural Networks (ConvNets). The basic understanding of ConvNet is that instead of learning complex function of entire receptive field, it learns representation from small region of the receptive fields. And in results, you need to have many feature maps in order to obtain better results.</p>

<p>Assume that you understand the idea of ConvNets, LRF-ELM firstly initialized \(K\) random filters (you can also orthogonalize these weights by using SVD), then it computes feature \(f^{(k)}\) by:</p>

<script type="math/tex; mode=display">f^{(k)}=F\left(X* w^{(k)}\right)</script>

<p>where \(w^{(k)}\) is the \(k\)-th random filter and \(F\) is the activation function. After this, you can then apply a pooling operation to the feature maps.</p>

<p>The rest story is simple then, you can simply flatten the feature maps and learn target by previous mentioned equation.</p>

<h3 id="lrf-elm-auto-encoder">LRF-ELM Auto-encoder</h3>

<p>The solution to LRF-ELM Auto-encoder is not so obvious once you tried to figure it out. Because LRF-ELM is similar to ConvNet, therefore you couldn’t use the same solution as previous to derive the result. Here after some investigation, I figured a way of learning filters in unsupervised learning manner.</p>

<p>Consider we have \(K\) filters (size doesn’t matter), then the feature map \(f^{(k)}\) is calculated as</p>

<p><script type="math/tex">f^{(k)}=F\left(X* w^{(k)}\right)</script>
where \(w^{(k)}\) is the \(k\)-th random filter and \(F(\cdot)\) is the activation function.</p>

<p>In the decoding stage, the filters can be learned by using feature maps as filter. And learned filter \(\hat{w}^{(k)}\) is computed by</p>

<script type="math/tex; mode=display">\hat{w}^{(k)}=X* f^{(k)}\cdot \left(\frac{1}{\frac{I}{C}+\sum\_{i,j}\left(f_{i,j}^{(k)}\right)^{2}}\right)</script>

<h3 id="incremental-learning-of-elm">Incremental Learning of ELM</h3>

<p>One of the problem of original ELM is that it doesn’t mention anything about dimension of the data. And in most of recent cases, it’s almost impossible to compute with entire data, therefore, we must find a way of learning output weights incrementally.</p>

<p>In previous paper <a href="http://www.ntu.edu.sg/home/egbhuang/pdf/OS-ELM-TNN.pdf">A Fast and Accurate Online Sequential Learning Algorithm for Feedforward Networks</a>, it offered a nice solution to this problem, you can update the output weight by:</p>

<script type="math/tex; mode=display">P\_{k+1}=P\_{k}-P\_{k}H\_{k+1}^{\top}\left(I+H\_{k+1}P\_{k}H\_{k+1}^{\top}\right)^{-1}H\_{k+1}P\_{k}</script>

<script type="math/tex; mode=display">W\_{o}^{k+1}=W\_{o}^{k}+P\_{k+1}H\_{k+1}^{\top}(T\_{k+1}-H\_{k+1}W\_{o}^{k})</script>

<p>where \(P_{k}=K_{k}^{-1}\). \(K_{0}\) is \(H_{0}^{\top}H_{0}\), \(W_{o}^{0}\) is \(K_{0}^{-1}H_{0}^{\top}T_{0}\) and</p>

<script type="math/tex; mode=display">K\_{k+1}=K\_{k}+H\_{k+1}^{\top}H\_{k}</script>

<p>You might think that if this is the way of computing output weights, then the LRF-ELM is a real mess. Turns out, it’s even simpler since \(K\) in LRF-ELM is a scalar. And it’s inverse is \(\frac{1}{K}\).</p>

<p>Another way of updating output weights is suggested by another paper: <a href="http://arxiv.org/abs/1412.8307">Fast, simple and accurate handwritten digit classification using extreme learning machines with shaped input-weights</a>. Instead of updating output weights, it simply updating to component of learning function: \(H^{\top}H\) and \(H^{\top}T\). In this way, you will only maintain this two fixed size matrix, and the output weights can be computed anytime from this two components. The updating rule is easy to derive:</p>

<script type="math/tex; mode=display">K\_{k+1}=K\_{k}+H\_{k+1}^{\top}H\_{k}</script>

<script type="math/tex; mode=display">A\_{k+1}=A\_{k}+H\_{k+1}^{\top}T\_{k+1}</script>

<p>where \(K_{0}=H_{0}^{\top}H_{0}\) and \(A_{0}=H_{0}^{\top}T_{0}\)</p>

<h3 id="maybe-another-way-of-training-elm">Maybe another way of training ELM</h3>

<p>So far we reviewed and explored variants of ELM. However, it doesn’t really fit in conventional Machine Learning where we use back-propagation and everything. The last section of incremental learning is somewhat “Machine Learning”-ish. I still felt it’s not natural enough.</p>

<p>This brought me to a recent proposed method, it is described in <a href="http://arxiv.org/abs/1411.0247">Random feedback weights support learning in deep neural networks</a>. I admired the approach that it is described. Without computing the gradient of weights and bias, one can still use back-propagation algorithm to train a neural network. With this approach, one can train MLP, ConvNets and other Feedforward Network variants without any trouble.</p>

<h3 id="generalizing-elm">Generalizing ELM</h3>

<p>I should say this again, the original proposal of ELM is a method that tries to generalize SLFNs. And it clearly tries to characterize either the output target or the signal itself. But it is not cleaning the data. In fact, most neural networks in the market does not try to clean the signal before they try to characterize it. The hope of cleaning data is on hierarchy structure and the abstract features is hoped to be clean. Have an ELM ever tried to characterize hidden activation itself? And instead of a hidden feedforward layer, can we replace it as a recurrent hidden layer? And if in this assumption, does ELM have to be a single-layered structure?</p>

<p>Okay, so far, like other neural networks, ELM tries to model either a target (classification labels or a regression target) or the input itself. This is conventional. However, what if we replace the target as hidden activation itself? So the cost function looks like this:</p>

<script type="math/tex; mode=display">J(H, W\_{o})=C||H\cdot W\_{o} - H||\_{p}^{\sigma\_{1}}+||W\_{o}||\_{q}^{\sigma\_{2}}</script>

<p>Is this even making any sense? Every one will say that in this case \(W_{o}\) is basically a regularized identity map. It’s very clear that the cost will decrease to 0 if \(W_{0}\) is an identity matrix. So, if it’s an identity matrix, why would I even try to learn it?</p>

<p>Well, wrong. There are plenty things you can discover. If you replace \(T\) as \(H\) in your ELM’s solution, it’s not hard to discover that actually this \(W_{o}\) is closely related to hidden activation’s correlation matrix. And, why does ELM’s hidden layer have to be a feedforward hidden layer? Can it be a recurrent layer? The answer is YES. And by the way, this whole thing is called conceptor network. It is developed by Herbert Jaeger from Jacobs University Bremen, you can find the complete technical paper from <a href="http://minds.jacobs-university.de/conceptors">here</a>. I think Professor Jaeger himself didn’t realized that there is a close relative of this idea that has been invented for almost 10 years.</p>

<p>Alright, so you can extend ELM to conceptors, what’s the big deal? The BIG DEAL is that ELM and it’s theory doesn’t have to be only a generalization of SLFNs, it can be a multi-layer hierarchy that can automatically clean and learn pattern of the data, offers a way of control neural dynamics naturally and biologically plausible. Well, I’m not going to review the full context of the naive conceptor formulation, but directly pay attention on its final offer of the entire theory: Random Feature Conceptor. (The following context needs understanding of naive conceptor and auto-conceptor). In following context, I’m using conceptor’s terminology.</p>

<p>The basic idea is to project reservoir state to a large feature state, so the formulation of the network is:</p>

<script type="math/tex; mode=display">r(n+1)=\tanh(Gz(n)+W^{\text{in}}p(n)+b)</script>

<script type="math/tex; mode=display">z(n+1)=\text{diag}(c(n))F'r(n)</script>

<p>where \(r(n)\in\mathbb{R}^{N\times 1}\), \(G\in\mathbb{R}^{N\times M}\), \(z(n)\in\mathbb{R}^{M\times 1}\), \(p(n)\in\mathbb{R}^{L\times 1}\), \(c(n)\in\mathbb{R}^{M\times 1}\), \(F’\in\mathbb{R}^{M\times N}\).</p>

<p>Now it’s easy to formulate the cost function as previous mentioned:</p>

<script type="math/tex; mode=display">J(z, c)=\frac{1}{M}\sum\_{i}||z\_{i}-c\_{i}z\_{i}||^{2}+\frac{\alpha^{-2}}{M}\sum\_{i}c\_{i}^{2}</script>

<p>You can also calculate the fixed-point solution in this way:</p>

<script type="math/tex; mode=display">c\_{i}=E\[z\_{i}^{2}\] (E[z\_{i}]+\alpha^{-2})^{-1}</script>

<p>And of course you can adapt the entire \(c\) using stochastic gradient descent.</p>

<p>Well, here is a drawback, and it’s a serious one: it’s very hard to scale up, especially for high-dimensional data like images. Withe millions of images, the system is going to compute between very large matrices.</p>

<p>At this point, we don’t really understand the full power of conceptor network and ELM yet. But one thing is for sure, there is no evidence where ELM or conceptor network is succeeded in large datasets, and this is also what we mostly worried.</p>


                    </div>
                
            </div>

            

            <div class=row-fluid>
                <div id=footer class=span12>
                    Documentation for <a href="http://www.dgyblog.com/">Random Thoughts</a>

<p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons Licence" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />Except where otherwise noted, content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></p>

<p><a href="https://ss.crowdprocess.com/opt-out.html">CrowdProcess</a> Is Running On Your Browser</p>

                </div>
            </div>
        </div>

        <script>
            function orderNav() {
                var list,
                    section,
                    header,
                    sections = [],
                    lists = {},
                    headers = {};

                var navUl = document.querySelectorAll('#navigation ul')[0],
                    navLis = document.querySelectorAll('#navigation ul li');

                if (!navUl) return;

                for (var i = 0; i < navLis.length; i++) {
                    var order, li = navLis[i];

                    if (li.classList.contains('nav-header')) {
                        section = li.textContent || li.innerText;
                        sections.push(section);
                        headers[section] = li;
                        continue;
                    }

                    if (!lists[section]) {
                        lists[section] = [];
                    }

                    order = parseFloat(li.getAttribute('data-order'))
                    lists[section].push([order, li]);
                }

                for (var i = 0; i < sections.length; i++) {
                    section = sections[i];
                    list = lists[section].sort(function(a, b) {
                        return a[0] - b[0];
                    });

                    if (header = headers[section]) {
                        navUl.appendChild(header);
                    }
                    for (var j = 0; j < list.length; j++) {
                        navUl.appendChild(list[j][1]);
                    }
                }
            }

            if (document.querySelectorAll) orderNav();
        </script>
        
        <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-19545856-3', 'auto');
  ga('send', 'pageview');
</script>

        
    </body>
</html>
